<%

# mako template for gcc-options-parser.bash
# mako is a superset of python

# config
# the "gcc" folder is in this folder:
gcc_src_dir = "./gcc"

import re, sys, os, glob

def separate_options_of_gcc_opt_file(gcc_opt_file):
  """
  return only the "separate" options, which consume the next argument
  """
  opts = []
  opt = null
  for line in open(gcc_opt_file, "r").readlines():
    line = line.strip()
    if line == "":
      if opt != null:
        if opt[0] != "Variable" and opt[0] != "###": # TODO parse sections: ###\nDriver
          opts.append(opt[:])
        opt = null
      continue
    if line[0] == ";":
      continue
    if opt == null:
      opt = []
    opt.append(line)

  if opt != null:
    opts.append(opt[:])
    opt = null

  #print("debug: opts = " + repr(opts))

  # TODO convert to rust structopt
  # structopt_options
  # variable_name
  # rust_type

  for i in range(len(opts)):
    opt = opts[i]

    long_name = opt[0]

    long_name = long_name.split("=")[0]
    long_name = long_name.split(",")[0]
    # TODO better

    long_name = "-" + long_name

    description = null
    try:
      description = opt[2]
    except IndexError:
      pass

    opts_opts = {}

    for m in re.findall(r"([^() ]+)(?:\(([^()]+)\))?", opt[1]):
      if True:
        m = [null, m[0], m[1]]
        if m[2]:
          opts_opts[m[1]] = m[2]
        else:
          opts_opts[m[1]] = True

    # test -> ok
    #if "Separate" in opts_opts:
    #  print(repr(opts_opts))

    variable_name = null
    try:
      variable_name = opts_opts["Var"]
    except KeyError:
      variable_name = long_name.replace("-", "_")

    # JoinedOrMissing: -time=timeval or time= (empty value)

    takes_value = False
    if "Joined" in opts_opts or "Separate" in opts_opts or "JoinedOrMissing" in opts_opts:
      takes_value = True
    
    short_name = null
    if len(long_name) == 2:
      short_name = long_name
      long_name = null

    opts[i] = {
      "variable_name": variable_name, # TODO use this
      "short_name": short_name,
      "long_name": long_name,
      "takes_value": False,
      "help_text": description,
      "opts_opts": opts_opts,
    }

  separate_options = []

  # TODO remove short/long name parsing, not used
  for opt in filter(lambda opt: "Separate" in opt["opts_opts"], opts):
    if opt["short_name"]:
      separate_options.append(opt["short_name"])
    if opt["long_name"]:
      separate_options.append(opt["long_name"])

  # TODO later sort by length ascending

  # filter unique, keep order
  #opts = list(dict.fromkeys(opts))
  # TODO later do this

  return separate_options




separate_options = []
for gcc_opt_file in glob.glob(gcc_src_dir+"/gcc/**/*.opt"):
  separate_options += separate_options_of_gcc_opt_file(gcc_opt_file)

# remove special cases
separate_options = filter(lambda s: s!="-o" and s!="-x", separate_options)

# filter unique, change order
separate_options = list(set(separate_options))

# sort by length ascending
separate_options = sorted(separate_options, key=lambda s: len(s))

%>\
#! /usr/bin/env bash

# NOTE this file was generated by gcc-options-parser.sh.mako

args=("$@")
#parsedArgs=()

# default values
iPathList=()
iLangList=()
iLang=none
oPath=a.out

${"for ((i = 0; i < ${#args[@]}; i++ ))"}
do
  ${"a=${args[$i]}"}
  case "$a" in
    -o*)
      [ -n "$oPath" ] && { echo "error: can have only one output"; exit 1; }
      if [ "$a" != "-o" ]; then ${"oPath=${a:2}"}; else : $((i++)); ${"oPath=${args[$i]}"}; fi
      echo "o: $oPath"
      ;;
    -x*)
      if [ "$a" != "-x" ]; then ${"iLang=${a:2}"}; else : $((i++)); ${"iLang=${args[$i]}"}; fi
      echo "f: $iLang"
      ;;
    ${"|".join(separate_options)})
      : $((i++))
      ${"b=${args[$i]}"}
      echo "2: $a $b"
      #parsedArgs+=("$a" "$b")
      ;;
    -*)
      echo "1: $a"
      #parsedArgs+=("$a")
      ;;
    *)
      echo "i: $a [format: $iLang]"
      iPathList+=("$a")
      # TODO if $iLang == "none", parse language from file extension
      iLangList+=("$iLang")
      ;;
esac

done
